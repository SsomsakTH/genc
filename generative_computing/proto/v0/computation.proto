syntax = "proto3";

package generative_computing.v0;

import "google/protobuf/any.proto";

option java_outer_classname = "ComputationProto";
option java_multiple_files = true;
option java_package = "org.generativecomputing";

// Represents a type of a value within a computation (or a computation itself,
// as a value of a functional type).
message Type {
  oneof type {
    FunctionType function = 1;
    StructType struct = 2;
    SequenceType sequence = 3;
    ScalarType scalar = 4;
    TensorType tensor = 5;

    // NEXT ID: 6
  }
}

// Represents a functional type.
message FunctionType {
  Type parameter = 1;
  Type result = 2;
}

// Represents a composite structure type (potentially nested).
message StructType {
  repeated Element element = 1;
  message Element {
    string name = 1;
    Type value = 2;
  }
}

// Represents a type of a sequence (of an unknown number of identically-typed
// elements).
message SequenceType {
  Type element = 1;
}

// Represents a scalar type.
// NOTE: The ordering of types in this enum is intended to be consistent with
// TensorFlow's `DType` to facilitate potential future interoperability (but
// one must no rely on this for correctness, as this property isn't guaranteed
// to be preserved in future refactoring).
enum ScalarType {
  SCALAR_TYPE_INVALID = 0;
  SCALAR_TYPE_FLOAT = 1;
  SCALAR_TYPE_DOUBLE = 2;
  SCALAR_TYPE_INT32 = 3;
  SCALAR_TYPE_UINT8 = 4;
  SCALAR_TYPE_INT16 = 5;
  SCALAR_TYPE_INT8 = 6;
  SCALAR_TYPE_STRING = 7;
  SCALAR_TYPE_COMPLEX64 = 8;
  SCALAR_TYPE_INT64 = 9;
  SCALAR_TYPE_BOOL = 10;
  SCALAR_TYPE_QINT8 = 11;
  SCALAR_TYPE_QUINT8 = 12;
  SCALAR_TYPE_QINT32 = 13;
  SCALAR_TYPE_BFLOAT16 = 14;
  SCALAR_TYPE_QINT16 = 15;
  SCALAR_TYPE_QUINT16 = 16;
  SCALAR_TYPE_UINT16 = 17;
  SCALAR_TYPE_COMPLEX128 = 18;
  SCALAR_TYPE_HALF = 19;
  SCALAR_TYPE_UINT32 = 22;
  SCALAR_TYPE_UINT64 = 23;
}

// Represents a tensor type.
message TensorType {
  ScalarType scalar = 1;
  repeated int64 dims = 2;
  bool unknown_rank = 3;
}

// A representation of a function call.
message Call {
  // A value of a functional type that represents the function to call, the
  // formal parameter to which must match the `argument`.
  Value function = 1;

  // A value that represents the argument to the function specified above.
  // Present if and only if "function" declares a parameter. This can be a
  // materializes value, or a value represented as a computation that must
  // be evaluated.
  Value argument = 2;
}

// A representation of a lambda expression.
message Lambda {
  // The name to use internally within this lambda to refer to the dynamic
  // parameter. The parameter is mandatory. The name defined here can be
  // subsequently referenced within the body of the `result` computation.
  string parameter_name = 1;

  // A computation that represents the result of applying the lambda to the
  // parameter. The result may contain references to the named parameter
  // defined above.
  Value result = 2;
}

// A reference by name (label) to a value defined earlier, either as a lambda
// parameter, or within a `Block`.
message Reference {
  string name = 1;
}

// Ordering is significant for symmetry with dynamic function calls. Name is
// optional because we only use it for semantics and during typechecking, at
// runtime name is not used, it's kept for debuggability.
message NamedValue {
  string name = 1;
  Value value = 2;
}

// A representation of a structured value. Elements can be either materialized
// values, or values represented as computations that must be evaluated (e.g.,
// such as function calls, selections, etc.).
message Struct {
  // The ordering of the elements is significant, regardless of whether they
  // are named or not, and must be preserved while processing to facilitate
  // selection by index (as defined below).
  repeated NamedValue element = 2;
  reserved 1;
}

// A representation of a selection from a struct.
message Selection {
  // The source of selection (required).
  Value source = 1;

  // A specification of which element to select by index.
  int32 index = 2;

  reserved 3;
}

// A representation of a `let` expression that incrementally defines a list of
// named values, and then refers to the values within the body of the `result`.
message Block {
  // One or more locals defined within the block, each associating a label with
  // a computation. Computations, whether those associated with the locals, or
  // that associated with the result below, can contain references to names
  // defined earlier. Self-references are prohibited. All names introduced here
  // must be different. Since execution semantics at this level is purely
  // functional without side effects, the ordering in which the locals are
  // declared is not significant as long as the declaration of any value in the
  // struct precedes its usage. It is only the dependencies between the
  // computations that effectively determine the causal relationships that
  // constrain the order of execution.
  Struct local = 1;

  // The result returned by the block (required). The result computation may
  // refer to any of the locals defined above by name.
  Value result = 2;
}

// A representation of an intrinsic.
message Intrinsic {
  // The URI that uniquely identifies the intrinsic within the set of operators
  // built into the framework.
  string uri = 1;

  // A set of zero or more static parameters for the intrinsic that are defined
  // as a part of the computation (as opposed to being dynamically computed at
  // runtime). The set of parameters that are accepted depends on the intrinsic.
  // Ordering is significant; names are optional. Note that intrinsics can, and
  // typically do also accept dynamic parameters (supplied via function calls,
  // as defined above), and it is only the types of the dynamic parameters that
  // are reflected in a given intrinsic's functional type signature.
  Value static_parameter = 2;
}

// A core data structure that represents a value in a generative AI computation
// in a portable, platform- and language-independent format, either in a
// materialized form (e.g., as a scalar or a struct), or as a computation that
// must be evaluated to product such a materialized form (e.g., a function all).
// Values can be of functional types, and functions are modeled as values.
// The constructs defined below can be arbitrarily nested, e.g., to define
// nested structures, cascading function calls, functions that accept multiple
// parameters, functions that take functions as parameters, etc.
message Value {
  // The type of this value (currently optional, eventually required where it
  // cannot be automatically inferred from the context).
  Type type = 13;

  oneof value {
    // CORE COMPOSITIONAL, STRUCTURED, AND FUNCTIONAL CONSTRUCTS FOR FORMING
    // COMPLEX TYPES OF VALUES AND COMPUTATION DEFINITIONS.

    // NOTE: This list is designed to be minimalistic, and intended to remain
    // stable. New operators, including control flow or higher-level operators,
    // must be defined as intrinsics (see below).

    // An invocation of a given function on a given argument. The function
    // being invoked can be any object of a functional type (e.g., a model
    // inference function, a prompt template constructor, an output parser,
    // a safety checker, or a lambda expression explicitly defined in this
    // proto, etc.), as long as its type signature matches the type of the
    // argument passed as input. The value of the computation is the result
    // returned by the function being called.
    Call call = 7;

    // A lambda expression defines a function that takes a single formal
    // parameter, and produces a single result (either potentially a struct,
    // a function, etc.). Lambdas can be nested.
    Lambda lambda = 8;

    // A reference to a name defined in a surrounding context, such as the
    // parameter within a lambda expression. The value of the reference is
    // the value of the object it refers to.
    Reference reference = 9;

    // A tuple that consists of orderded, and optionally named, values.
    // Structs are used, e.g., to assemble multiple values to form a complex
    // argument to a function call, or to represent a complex results. They
    // can be nested to model complex data structures.
    Struct struct = 6;

    // A selection of an element from a struct. Selections are used, e.g.,
    // to extract a part of a result of one computation to feed as a part of
    // an argument to a subsequent computation.
    Selection selection = 10;

    // A block of computation logic that consists of a series of assignments,
    // followed by a computation that produces the final result. The named
    // values produced by the assignments can appear in the result, and/or in
    // assignments further down the list.
    Block block = 11;

    // An intrinsic. Intrinsics are functions with well-defined semantics that
    // are supported by the framework, natively understood by the reference set
    // of runtime components, and used to support the core functionality,
    // including interoperability with popular types of frontend SDKs, model
    // cascading and other types of hybrid computing patterns, etc. Intrinsics
    // range from simple transformations on data (e.g., a prompt template, an
    // output parser, or a model inference function) to operators that accept
    // functions as arguments (e.g., conditionals, loops, fallback, and other
    // control flow or higher-level functional operators).
    // TODO(b/295013978): Document here where the supported types of intrinsics
    // are listed, and where to add new ones.
    Intrinsic intrinsic = 12;

    // REPRESENTATIONS OF MATERIALIZED VALUES (SCALARS, TENSORS, MEDIA TYPES).

    // NOTE: This list is expected to grow, but where possible, we default to
    // using representations that already exist (e.g., nested structures of
    // scalars), rather than embedding new formats that duplicate the existing
    // functionality, except where a new representation might need to be
    // introduced for performance reasons.

    // The preferred representation for string values.
    string str = 3;

    // The preferred representation for Boolean values.
    bool boolean = 4;

    // The preferred representation for media values, e.g. image/audio.
    bytes media = 5;

    // A serialized tensor content as an instance of `tensorflow.TensorProto`,
    // as defined in `tensorflow/core/framework/tensor.proto`. This is
    // currently the only way to pass in numeric or string values, including
    // simple scalars.
    // NOTE: This must be `Any` in order to avoid a dependency on TensorFlow.
    google.protobuf.Any tensor = 1;

    // NEXT ID: 14
  }

  reserved 2;
}
