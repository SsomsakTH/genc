# Generative Computing (GenC) APIs

## Overview

The API surface offered by GenC consists of roughly three parts, each targeting
a somewhat different audience, discussed in separate sections below:

*   **Authoring APIs** facilitate construction of *intermediate representation*
    (*IR* for short) i.e., instances of the
    [`computation.proto`](../../proto/v0/computation.proto)'s, by the
    application developers to express the application logic that they want to
    run using GenC in a portable platform- and language-independent manner.

*   **Runtime APIs** facilitate execution of the IR that was created using the
    authoring APIs, in various application contexts. This enables application
    developers to embed the authored IR within their applications (e.g., as an
    ordinary Java callable object in a Java app on Android).

*   **Extensibility APIs** enable power users and platform partners to customize
    the platform for advanced use cases (e.g., connect to custom backends, add
    custom types of operators, etc.), and to contribute new capabilities to
    support new types of frontends, backends, etc., for other customers to use.

## Authoring APIs

There are two kinds of authoring APIs: *interoperability* APIs that enable GenC
to consume code written using another SDK (e.g., LangChain), and lower-level
*native* APIs that the above are layered upon, and that enable advanced uses or
that can be used to add support for new types of frontend SDKs.

### Interop authoring APIs

These authoring APIs enable the developer to define their application logic
using their preferred external SDK, and then have that logic translated into the
IR form with a one-liner call. By convention, the translation call is always
named `genc.interop.XYZ.create_computation(...)` in Python (or in an equivalent
manner in other languages), where `XYZ` is the name of the SDK from which to
convert, the argument represents an object constructed using that SDK, and the
result is a well-formed GenC IR.

In addition, interop APIs contain various extensions that are intended to
augment the SDKs with additional functionality, typically as subclasses that
implement interfaces defined by those SDKs.

At this time, the only supported SDK is LangChain. Over time, we aim to grow the
set of supported SDKs with the help of the 3P/OSS community.

#### Interop authoring APIs for LangChain

These can be found in the
[python/interop/langchain](../../python/interop/langchain/) directory.

Currently included:

*   The converter call `genc.interop.langchain.create_computation` (see above)
    that, at the time of this writing, understands models, prompt templates,
    chains, agents, and custom extensions listed below (with more to be added
    over time).

*   Extensions for custom models, model cascades, chains, agents, and tools that
    implement the base interfaces defined in LangChain.

The snippet below illustrates the use of several of the above:

```
my_chain = langchain.chains.LLMChain(
    llm=genc.interop.langchain.CustomModel(uri="/cloud/gemini"),
    prompt=langchain.prompts.PromptTemplate(
        input_variables=["location"],
        template="Q: What should I pack for a trip to {location}? A: ",
    ),
)

portable_ir = interop.langchain.create_computation(my_chain)
```

### Native authoring APIs

These APIs enable the developer to directly construct the IR, and for the most
part, they map in a roughly one-to-one manner to the IR constructs. In addition
to APIs that map 1:1 to the IR constructs, we offer a handful of convenience
APIs layered on top of those to support writing more compact code. Over time, we
anticipate these to evolve into separate higher-level API layers. As noted
above, the primary audience for these APIs is framework and platform partners
who want to implement interop APIs for new types of SDKs, and power users who
need direct control and customizability, e.g., to complement code written in an
external SDK with a segment that can't be expressed in that SDK due to its
limitations (but can be coded directly using a native authoring API and merged
with the IR generated by the converter).

The authoring APIs are currently offered in C++ and in Python, with Java and
other languages coming later. The API is consistent across all languages, with
C++ offering the most complete coverage, and other languages in sync via the
appropriate language-specific bindings (such as `pybind11`, `JNI`, etc.).

**C++ native authoring APIs** can be found in
[cc/authoring](../../cc/authoring/), with all the basic IR constructs defined
in [constructor.h](../../cc/authoring/constructor.h). Longer descriptions of
these basic primitives can be found in
[cc/intrinsics/intrinsic_uris.h](../../cc/intrinsics/intrinsic_uris.h). Note
that this system of operators is extensible. Deployments using GenC can add new
operators targeting their specific problem domain that aren't listed or
documented here. All functions in the authoring API take and return pieces of
the IR, and are named `CreateXXX` after the element of the IR they are designed
to construct.

The snippet below illustrates the use of the C++ authoring to expressed an agent
reasoning example (you can find the full working code in
[cc/examples/math_tool_agent.cc](../../cc/examples/math_tool_agent.cc)):

```
// Create modular computations, orders doesn't matter, these are just protos.
// We employ lazy execution here. (eager is possible too).
// Logger prints to terminal
v0::Value log_it = GENC_TRY(CreateLogger());

// Context keeps the interaction history with model.
v0::Value read_context = GENC_TRY(CreateCustomFunction("/local_cache/read"));
v0::Value add_to_context =
    GENC_TRY(CreateCustomFunction("/local_cache/write"));

// Create a custom model call by utilizing Gemini behind REST endpoint.
std::string api_key = absl::GetFlag(FLAGS_api_key);
std::string end_point =
    "https://generativelanguage.googleapis.com/v1beta/models/"
    "gemini-pro:generateContent?key=" +
    api_key;
v0::Value rest_call = GENC_TRY(CreateRestCall(end_point));
v0::Value str_to_json_request =
    GENC_TRY(CreateCustomFunction("/gemini_parser/wrap_text_as_input_json"));
v0::Value extrat_top_candidate = GENC_TRY(
    CreateCustomFunction("/gemini_parser/get_top_candidate_as_text"));
SmartChain model_call =
    SmartChain() | str_to_json_request | rest_call | extrat_top_candidate;

// We use WolframAlpha as a Tool to solve simple math questions.
std::string appid = absl::GetFlag(FLAGS_appid);
v0::Value extract_result_from_wolfram = GENC_TRY(CreateInjaTemplate(
    "{% if queryresult.pods %}{{queryresult.pods.0.subpods.0.plaintext}}{% "
    "endif %}"));
SmartChain solve_math =
    SmartChain() | CreateWolframAlpha(appid) | extract_result_from_wolfram;

SmartChain reasoning_loop =
    SmartChain() | read_context | model_call |
    CreateCustomFunction("/react/parse_thought_action") | log_it |
    CreateRegexPartialMatch("Finish") | add_to_context |
    CreateCustomFunction("/react/extract_math_question") | solve_math |
    CreateCustomFunction("/react/format_observation") | log_it |
    add_to_context;

// Set the max number of iterations of a reasoning loop.
// This utilizes a RepeatedConditionalChain under the hood, which allows a
// chain to be repeatedly executed until a break condition is met.
reasoning_loop.SetNumIteration(8);

SmartChain step_by_step_math_agent =
    SmartChain() | CreatePromptTemplate(kInstructionTemplate) |
    add_to_context | log_it | reasoning_loop;

v0::Value computation = GENC_TRY(step_by_step_math_agent.Build());
```

**Python native authoring APIs** are lifted from C++ via
[constructor_bindings.cc](../../cc/authoring/constructor_bindings.cc), and can
be found re-exported with additional documentation in
[python/authoring/constructors.py](../../python/authoring/constructors.py), and
with names, types of arguments and results closely matching those from C++ (but
adapted for use in Python).

In addition, as an added convenience in constructing more complex IR logic,
there's experimental support for defining IR via decorated Python functions that
are traced; see
[python/examples/authoring_demo.py](../../python/examples/authoring_demo.py) or
the snippet below for an example of what this looks like.

```
@genc.authoring.traced_computation
def comp(x):
    template_str = "Q: What should I pack for a trip to {location}? A: "
    prompt = genc.authoring.prompt_template[template_str](x)
    model_output = genc.authoring.model_inference["test_model"](prompt)
    return model_output
```

This form of authoring is currently under development.

**Java native authoring APIs** currently don't exist, but will be added in a
manner that mirrors those in Python, by virtue of lifting C++ authoring APIs
via JNI and adapting them for usage from within Java.

## Runtime APIs

## Extensibility APIs
